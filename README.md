# Huffman_Twitter_Bot
TLDR:Bot that uses the huffman coding algorithm to compress tweets with the keyword "compress" and can decode those messages with the keyword " decode ". Twitter bot username is @bot90861498. Bot must be mentioned in the tweet. I also can't guarantee the bot will be up 24/7, it is running on a server through heroku and I'm kinda cheap :(

How it works/how it uses the twitter api: Through tweepy/python and some authentication keys it uses the twitter API. From there, it uses the twitter API to sort through statuses (tweets) that it was mentioned in. To prevent the bot from replying to statuses (tweets) that it has already replied to, it adds the id of every mention to a list and before every tweet it will check to make sure the id of the mention is not contained in this list. When the bot replies to a mention, it adds the mention id to the list. My bot also uses the twitter api to create statuses (tweet). My bot will only reply to mentions that contain the key words "compress" " decode " and "time" (time just tells you the current time UTC). 

Huffman algorithm: This symbol code compression algorithm traditionally uses a priority queue and a binary tree to sort and encode messages based on the frequencies of characters. In my implementation I used a list instead of a pqueue, but it functions just as well. Essentially the goal of this algorithm is to reduce the entropy of the message, or in other words the number of bits per symbol. Most symbols are encoded using ASCII which uses 8 bits per symbol. This is typically much more than needed. For instance if I have a message which only contains say 26 unique symbols, do I really need 8 bits per character? Instead we can use a compression algorithm like Huffman's. This algorithm works by assigning each character with a frequency. The characters and their corresponding frequencies are then sorted in ascending order. From here, a binary tree is constructed from the bottom up, with the symbols and the frequencies being leaf nodes. In every iteration, a new node is created by adding the two lowest frequencies together and assigning the left and right nodes of this new node to the two nodes with the lowest frequencies. This continues until there is just one node left, some people like to call it the root node, but I think papa node is more fun. Next, the list is encoded by starting from the papa node and adding 1s to the codes of left nodes and 0s to the codes of the right nodes (this is a recursive process). Once this is done, it grabs all of the symbols and codes of the leaf nodes and makes a key out of them. The key looks something like this: [a011,b11] where the brackets signify the beginning and ending of the key and the characters are followed by their respective binary codes. The algorithm then encodes the original message with this new key. I also forgot to mention that since this algorithm uses a binary tree to encode the data with 1s and 0s, it is naturally a prefix code, meaning that no one code is a prefix to another code, making it very simple to decode the encoded message. To decode the newly encoded message, all my algorithm must do is read in the key and iterate through the message. As it goes through it checks if the current combination matches the code in the key, if it does, great it just adds the corresponding character to the decoded message it is creating and resets the current combination; if the current combination doesn't match any codes in the key it simply adds the current character to the current combination and continues. If all goes well, it sends the decoded message, if not then it replies with, "I wasn't able to decode your message :(". My bot can be a little picky when decoding, if you don't copy/paste the exact message my bot sent when compressing your message (excluding the old size was: _ new size is: _ part) then it won't work. If you don't separate "decode" from that block of text with white space then it won't work. 





